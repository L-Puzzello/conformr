---
title: "How to Make Panel Maps"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Panel Maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(conformr)
```

# What are Panel maps? (Conceptual)

_Panel Maps_ are the architectural blueprints of your combined dataset. It specifies instructions for combining and splitting values from source classification into a target classification.

# How-to create Panel Maps from... (How to Guide)

One of the key steps in the `{conformr}` workflow is the creation of _Panel Maps_. The following sections provide example code for generating _Panel Maps_ from a variety of sources. Familiarity with the specific classifications, which are chosen purely for illustration purposes, is not necessary.

# Panel Maps, the tidy way

Note that these examples use a number of external packages, in particular `{tidyverse}`. This is to demonstrate how easily `{conformr}` can fit into existing tidy workflows.

## Correspondence Tables.. (Tutorial)

Say you have a correspondence table which specifies the complete connections between two code structures, how do you turn that table into a _Panel Map_?

Let's create a Panel Map to transform <<<<trade data>>>>> from version <<x>> of the [Harmonised System](https://en.wikipedia.org/wiki/Harmonized_System) (`HS1_6d`) to NAICS (`code_out`) at the 6 digit code level. First, we import the relevant correspondence table, and then select the columns with the source and target codes. 
```{r import-concordance}
library(concordance)
library(magrittr)
library(dplyr)

code_dict <- concordance::hs1_naics %>%
  distinct(HS1_6d, NAICS_6d)
```
Notice that we kept only the unique combinations of HS1 & NAICS using `dplyr::distinct()`. We use `distinct` ensure that we have the correct denominator for splitting up values that are part of a 1-to-many split. See the [Verification of Panel Maps]() vignette for more details.

Now, let's group by our source classification `HS1_6d` to see what kind of transformations will be included in our Panel Map:
```{r mapping-cases}
code_dict %>%
  group_by(HS1_6d) %>%
  summarise(n_dest = n_distinct(NAICS_6d),
            dest_codes = paste(NAICS_6d, collapse = ",")) %>%
  mutate(map_type = case_when(n_dest == 1 ~ "1-to-1 OR many-to-1",
                              n_dest > 1 ~ "1-to-many"))
```

```{r}
code_dict %>%
  group_by(HS1_6d) %>%
  mutate(n_dest = n_distinct(NAICS_6d)) %>%
  ungroup() %>%
  group_by(NAICS_6d) %>%
  mutate(dest_size = n_distinct(HS1_6d)) %>%
  mutate(map_case = case_when(n_dest == 1 & dest_size == 1 ~ "1-to-1",
                              n_dest == 1 & dest_size != 1 ~ "many-to-1",
                              n_dest != 1 & dest_size != 1 ~ "1-to-many")) %>%
  group_by(HS1_6d, n_dest, map_case) %>%
  summarise(dest_codes = paste(NAICS_6d, collapse = ","))
```


```{r generate-panel-map}
panel_map <- code_dict %>%
  group_by(HS1_6d) %>%
  mutate(n_dest = n(),
         HS1_split = 1/n_dest)

panel_map
```
```{r sankey-panel-map}
library(ggplot2)
library(ggalluvial)

panel_map %>%
  mutate(HS1_chapter = substr(HS1_6d, 1, 2)) %>%
  filter(HS1_chapter == "01") %>%
  mutate(map_type = case_when(n_dest == 1 ~ "1-to-1 OR many-to-1",
                              n_dest > 1 ~ "1-to-many")) %>%
  ggplot(., 
         aes(axis1 = HS1_6d, axis2 = NAICS_6d,
             y = n_dest)) +
  scale_x_discrete(limits = c("HS1", "NAICS"), expand = c(.2, .05)) +
  xlab("Classification") +
  geom_alluvium(aes(fill = map_type)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal()
  
```


```{r}
panel_map %>%

```


## Existing scripts

## Grouped Panel Maps

In cases where

